/*
Homework: Create a flow field and then have an array of vehicles follow it
 
 Tori Mondello
 February 10 2021
 
 Based on examples from The Nature of Code by Daniel Shiffman
 and class lecture notes from Michael Shiloh
 
 */

FlowField f; 
ArrayList <Vehicle> v = new ArrayList<Vehicle>();

void setup() {
  size (1200, 800);
  f = new FlowField(30);    //create a new flow field with a resolution of 30
  // display the flow field

  /* //uncomment these next two lines to view the flowfield
  //note: make sure to comment out the background in draw()
  f.display();   
  background((55, 55, 100); 
*/

}


void draw() {
  background(55, 55, 100);  //comment this out to view the flowfield

  for (Vehicle v : v) {  //use an enhanced loop to cycle through the vehicles
    v.update();  
    v.display();
    v.follow(f);  //have the vehicles follow the flowfield
  }
}

void keyPressed() {
  if (key == ' ') {  
    v.add(new Vehicle(mouseX, mouseY));    //when the space is pressed, add a new vehicle at mouse location
    println("added a new PVector at this mouse location");
  }
}

/*
//Or, comment out the keyPressed() and uncomment mousePressed()

void mousePressed(){
  v.add(new Vehicle(mouseX, mouseY));
   println("added a new PVector at this mouse location");
}

*/

// The flow field class, more or less straight from the book
// with the addition of the display() function and different
// initialization options (each of which is from the book)
class FlowField {

  PVector[][] field;  
  PVector center;  //a PVector for center facing flowField
  int cols, rows;
  int resolution; // Size of each square in the grid, in pixels

  // Constructor takes the desired resolution
  FlowField(int _res) {
    resolution = _res;
    cols = width/resolution;
    rows = height/resolution;

    // Declare the array of PVectors which will hold the field
    field = new PVector[cols][rows];


    // Initialize the field using one of the three options below

   // centerFlowField();
    // randomFlowField();
     perlinFlowField();
  }

  // Pretty boring; all vectors point to the right
  void centerFlowField() {
    for (int i = 0; i < cols; i++) {    
      for (int j = 0; j < rows; j++) {
        center = new PVector(map(i, 0, cols, 1, -1), map(j, 0, rows, 1, -1));  //determine whether its inward or outward facing
        center.normalize();
        field[i][j] = center;    
      }
    }
  }

  void randomFlowField() {
    for (int i = 0; i < cols; i++) {
      for (int j = 0; j < rows; j++) {
        field[i][j] = PVector.random2D();
      }
    }
  }

  // Use perlin noise to determine the angle of each vector
  void perlinFlowField() {

    float xoff = 0;
    for (int i = 0; i < cols; i++) {
      float yoff = 0;
      for (int j = 0; j < rows; j++) {

        // Moving through the noise() space in two dimensions
        // and mapping the result to an angle between 0 and 360
        float theta = map(noise(xoff, yoff), 0, 1, 0, TWO_PI);

        // Convert the angle (polar coordinate) to Cartesian coordinates
        field[i][j] = new PVector(cos(theta), sin(theta));

        // Move to neighboring noise in Y axis
        yoff += 0.1;
      }

      // Move to neighboring noise in X axis
      xoff += 0.1;
    }
  }

  // Given a PVector which defines a location in the flow field,
  // return a copy of the value of the flow field at that location
  PVector lookup(PVector lookup) {

    // Convert x and y values to row and column, and constrain
    // to stay within the field
    int column = int(constrain(lookup.x/resolution, 0, cols-1));
    int row = int(constrain(lookup.y/resolution, 0, rows-1));

    return field[column][row].copy();
  }

  // Display the flow field so we can see if it looks like what we think it should
  //
  void display() {
    for (int i = 0; i < cols; i++) {
      for (int j = 0; j < rows; j++) {
        print("col " + i + " row " + j + "  ");
        println(i*resolution, j*resolution, field[i][j].x, field[i][j].y);
        pushMatrix();

        // This translates to the top left corner of the grid, but really
        // it should center the vector in the middle of the grid
        translate(i*resolution, j*resolution);
        PVector f = field[i][j].copy();
        f.mult(resolution);
        line(0, 0, f.x, f.y);
        ellipse(f.x, f.y, 5, 5); // circle instead of arrow head
        popMatrix();
      }
    }
  }
}


// The vehicle class, more or less straight from the book
class Vehicle {

  PVector location;
  PVector velocity;
  PVector acceleration;
  // Additional variable for size
  float r;
  float maxforce;
  float maxspeed;

  Vehicle(float x, float y) {
    acceleration = new PVector(0, 0);
    velocity = new PVector(0, 0);
    location = new PVector(x, y);
    r = 3.0;
    //Arbitrary values for maxspeed and
    // force; try varying these!
    maxspeed = 4;
    maxforce = 10;
  }

  // Update the velocity and location, based on the acceleration generated by the steering force
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0); // clear the acceleration for the next frame
  }

  // Newtonâ€™s second law; we could divide by mass if we wanted.
  // If there are multiple forces (e.g. gravity, wind) we use
  // this function for each one, and it is added to the acceleration
  void applyForce(PVector force) {
    acceleration.add(force);
  }

  /*
  What follows are different steering algorithms. A vehicle
   could use any one, and you could create addiotional ones.
   Each algorithm calculates the steering force and then
   applies it
   */

  // Calculate steering force to seek a target
  void seek(PVector target) {
    PVector desired = PVector.sub(target, location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }

  // Calculate the steering force to follow a flow field
  void follow(FlowField flow) {
    // Look up the vector at that spot in the flow field
    PVector desired = flow.lookup(location);
    desired.mult(maxspeed);

    // Steering is desired minus velocity
    PVector steer = PVector.sub(desired, velocity);
    steer.limit(maxforce);
    applyForce(steer);
  }

  void display() {
    // Vehicle is a triangle pointing in
    // the direction of velocity; since it is drawn
    // pointing up, we rotate it an additional 90 degrees.
    float theta = velocity.heading() + PI/2;
    fill(255, 200, 200);    //make it pinkish
    stroke(0);
    pushMatrix();
    translate(location.x, location.y);
    rotate(theta);
    beginShape();
    vertex(0, -r*2);
    vertex(-r, r*2);
    vertex(r, r*2);
    endShape(CLOSE);
    popMatrix();
  }
}

